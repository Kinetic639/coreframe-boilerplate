import { createClient } from "@/lib/supabase/client";
import { Database } from "@/types/supabase";

type Tables = Database["public"]["Tables"];
type Invitation = Tables["invitations"]["Row"];
type InvitationInsert = Tables["invitations"]["Insert"];
type InvitationUpdate = Tables["invitations"]["Update"];

export interface InvitationWithDetails extends Invitation {
  role?: {
    id: string;
    name: string;
    display_name: string | null;
  } | null;
  branch?: {
    id: string;
    name: string;
  } | null;
  organization?: {
    id: string;
    name: string;
  } | null;
}

export interface CreateInvitationData {
  email: string;
  role_id: string;
  branch_id: string;
  organization_id: string;
  invited_by: string;
  expires_at?: string;
}

export interface UpdateInvitationData {
  status?: "pending" | "accepted" | "rejected" | "expired" | "cancelled";
  expires_at?: string;
}

/**
 * Create a new invitation
 */
export async function createInvitation(data: CreateInvitationData): Promise<Invitation> {
  const supabase = createClient();

  // Set default expiration to 7 days from now if not provided
  const expiresAt = data.expires_at || new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString();

  const invitationData: InvitationInsert = {
    email: data.email.toLowerCase().trim(),
    role_id: data.role_id,
    branch_id: data.branch_id,
    organization_id: data.organization_id,
    invited_by: data.invited_by,
    status: "pending",
    expires_at: expiresAt,
    token: "", // Will be auto-generated by trigger
  };

  const { data: invitation, error } = await supabase
    .from("invitations")
    .insert(invitationData)
    .select()
    .single();

  if (error) {
    throw new Error(`Failed to create invitation: ${error.message}`);
  }

  return invitation;
}

/**
 * Fetch invitations for an organization with details
 */
export async function fetchOrganizationInvitations(
  organizationId: string
): Promise<InvitationWithDetails[]> {
  const supabase = createClient();

  // First, get the invitations
  const { data: invitations, error: invitationsError } = await supabase
    .from("invitations")
    .select("*")
    .eq("organization_id", organizationId)
    .order("created_at", { ascending: false });

  if (invitationsError) {
    throw new Error(`Failed to fetch invitations: ${invitationsError.message}`);
  }

  if (!invitations || invitations.length === 0) {
    return [];
  }

  // Get unique IDs for related data
  const roleIds = Array.from(new Set(invitations.map((inv) => inv.role_id).filter(Boolean)));
  const branchIds = Array.from(new Set(invitations.map((inv) => inv.branch_id).filter(Boolean)));
  const orgIds = Array.from(new Set(invitations.map((inv) => inv.organization_id).filter(Boolean)));

  // Fetch related data in parallel
  const [rolesData, branchesData, organizationsData] = await Promise.all([
    roleIds.length > 0
      ? supabase.from("roles").select("id, name, display_name").in("id", roleIds)
      : { data: [], error: null },
    branchIds.length > 0
      ? supabase.from("branches").select("id, name").in("id", branchIds)
      : { data: [], error: null },
    orgIds.length > 0
      ? supabase
          .from("organization_profiles")
          .select("organization_id, name")
          .in("organization_id", orgIds)
      : { data: [], error: null },
  ]);

  // Create lookup maps
  const rolesMap = new Map((rolesData.data?.map((role) => [role.id, role]) || []) as any);
  const branchesMap = new Map(
    (branchesData.data?.map((branch) => [branch.id, branch]) || []) as any
  );
  const organizationsMap = new Map(
    (organizationsData.data?.map((org) => [
      org.organization_id,
      { id: org.organization_id, name: org.name },
    ]) || []) as any
  );

  // Combine data
  const result: InvitationWithDetails[] = invitations.map((invitation) => ({
    ...invitation,
    role: invitation.role_id ? rolesMap.get(invitation.role_id) || null : null,
    branch: invitation.branch_id ? branchesMap.get(invitation.branch_id) || null : null,
    organization: invitation.organization_id
      ? organizationsMap.get(invitation.organization_id) || null
      : null,
  }));

  return result;
}

/**
 * Fetch invitation by token
 */
export async function fetchInvitationByToken(token: string): Promise<InvitationWithDetails | null> {
  const supabase = createClient();

  // First, get the invitation
  const { data: invitation, error: invitationError } = await supabase
    .from("invitations")
    .select("*")
    .eq("token", token)
    .single();

  if (invitationError) {
    if (invitationError.code === "PGRST116") {
      return null; // Invitation not found
    }
    throw new Error(`Failed to fetch invitation: ${invitationError.message}`);
  }

  if (!invitation) {
    return null;
  }

  // Fetch related data in parallel
  const [roleData, branchData, organizationData] = await Promise.all([
    invitation.role_id
      ? supabase
          .from("roles")
          .select("id, name, display_name")
          .eq("id", invitation.role_id)
          .single()
      : { data: null, error: null },
    invitation.branch_id
      ? supabase.from("branches").select("id, name").eq("id", invitation.branch_id).single()
      : { data: null, error: null },
    invitation.organization_id
      ? supabase
          .from("organization_profiles")
          .select("organization_id, name")
          .eq("organization_id", invitation.organization_id)
          .single()
      : { data: null, error: null },
  ]);

  // Combine data
  const result: InvitationWithDetails = {
    ...invitation,
    role: roleData.data || null,
    branch: branchData.data || null,
    organization: organizationData.data
      ? { id: organizationData.data.organization_id, name: organizationData.data.name }
      : null,
  };

  return result;
}

/**
 * Update invitation status
 */
export async function updateInvitation(
  invitationId: string,
  data: UpdateInvitationData
): Promise<Invitation> {
  const supabase = createClient();

  const updateData: InvitationUpdate = {
    ...data,
  };

  const { data: invitation, error } = await supabase
    .from("invitations")
    .update(updateData)
    .eq("id", invitationId)
    .select()
    .single();

  if (error) {
    throw new Error(`Failed to update invitation: ${error.message}`);
  }

  return invitation;
}

/**
 * Cancel invitation
 */
export async function cancelInvitation(invitationId: string): Promise<void> {
  const supabase = createClient();

  const { error } = await supabase
    .from("invitations")
    .update({
      status: "cancelled",
      updated_at: new Date().toISOString(),
    })
    .eq("id", invitationId);

  if (error) {
    throw new Error(`Failed to cancel invitation: ${error.message}`);
  }
}

/**
 * Accept invitation
 */
export async function acceptInvitation(token: string): Promise<Invitation> {
  const supabase = createClient();

  const { data: invitation, error } = await supabase
    .from("invitations")
    .update({
      status: "accepted",
      accepted_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    })
    .eq("token", token)
    .eq("status", "pending")
    .select()
    .single();

  if (error) {
    throw new Error(`Failed to accept invitation: ${error.message}`);
  }

  return invitation;
}

/**
 * Reject invitation
 */
export async function rejectInvitation(token: string): Promise<Invitation> {
  const supabase = createClient();

  const { data: invitation, error } = await supabase
    .from("invitations")
    .update({
      status: "rejected",
      rejected_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    })
    .eq("token", token)
    .eq("status", "pending")
    .select()
    .single();

  if (error) {
    throw new Error(`Failed to reject invitation: ${error.message}`);
  }

  return invitation;
}

/**
 * Check if email is already invited to organization
 */
export async function checkEmailInvited(organizationId: string, email: string): Promise<boolean> {
  const supabase = createClient();

  const { data, error } = await supabase
    .from("invitations")
    .select("id")
    .eq("organization_id", organizationId)
    .eq("email", email.toLowerCase().trim())
    .in("status", ["pending", "accepted"])
    .limit(1);

  if (error) {
    throw new Error(`Failed to check email invitation status: ${error.message}`);
  }

  return (data && data.length > 0) || false;
}

/**
 * Check if email is already a user in the organization
 */
export async function checkEmailIsUser(organizationId: string, email: string): Promise<boolean> {
  const supabase = createClient();

  const { data, error } = await supabase
    .from("users")
    .select("id")
    .eq("email", email.toLowerCase().trim())
    .is("deleted_at", null)
    .limit(1);

  if (error) {
    throw new Error(`Failed to check if email is existing user: ${error.message}`);
  }

  if (!data || data.length === 0) {
    return false;
  }

  // Check if user is in the organization via user_organizations table
  const { data: orgUsers, error: orgError } = await supabase
    .from("user_organizations")
    .select("id")
    .eq("organization_id", organizationId)
    .eq("user_id", data[0].id)
    .limit(1);

  if (orgError && orgError.code !== "PGRST116") {
    // PGRST116 = no rows found
    throw new Error(`Failed to check user organization membership: ${orgError.message}`);
  }

  if (orgUsers && orgUsers.length > 0) {
    return true;
  }

  // Also check if user is the owner of the organization
  const { data: orgData, error: ownerError } = await supabase
    .from("organization_profiles")
    .select("organization_id")
    .eq("organization_id", organizationId)
    .eq("created_by", data[0].id)
    .limit(1);

  if (ownerError && ownerError.code !== "PGRST116") {
    throw new Error(`Failed to check organization ownership: ${ownerError.message}`);
  }

  return (orgData && orgData.length > 0) || false;
}

/**
 * Get invitation statistics for organization
 */
export async function fetchInvitationStatistics(organizationId: string) {
  const supabase = createClient();

  const { data: invitations, error } = await supabase
    .from("invitations")
    .select("status")
    .eq("organization_id", organizationId);

  if (error) {
    throw new Error(`Failed to fetch invitation statistics: ${error.message}`);
  }

  const stats = {
    total: invitations?.length || 0,
    pending: invitations?.filter((inv) => inv.status === "pending").length || 0,
    accepted: invitations?.filter((inv) => inv.status === "accepted").length || 0,
    rejected: invitations?.filter((inv) => inv.status === "rejected").length || 0,
    expired: invitations?.filter((inv) => inv.status === "expired").length || 0,
    cancelled: invitations?.filter((inv) => inv.status === "cancelled").length || 0,
  };

  return stats;
}

/**
 * Mark expired invitations as expired
 */
export async function markExpiredInvitations(): Promise<number> {
  const supabase = createClient();

  const { data, error } = await supabase
    .from("invitations")
    .update({
      status: "expired",
      updated_at: new Date().toISOString(),
    })
    .eq("status", "pending")
    .lt("expires_at", new Date().toISOString())
    .select("id");

  if (error) {
    throw new Error(`Failed to mark expired invitations: ${error.message}`);
  }

  return data?.length || 0;
}
